{"remainingRequest":"/Users/amou/Documents/GitHub/demo1/news/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/amou/Documents/GitHub/demo1/news/src/components/AuthInput.vue?vue&type=style&index=0&id=f386339c&lang=less&scoped=true&","dependencies":[{"path":"/Users/amou/Documents/GitHub/demo1/news/src/components/AuthInput.vue","mtime":1581495599369},{"path":"/Users/amou/Documents/GitHub/demo1/news/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/amou/Documents/GitHub/demo1/news/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/amou/Documents/GitHub/demo1/news/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/amou/Documents/GitHub/demo1/news/node_modules/less-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/amou/Documents/GitHub/demo1/news/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/amou/Documents/GitHub/demo1/news/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgovLyBoMSB7Ci8vICAgY29sb3I6IGdyZWVuOwovLyB9Ci5pbnB1dC13cmFwcGVyIHsKICBwYWRkaW5nOiA1LjU1NnZ3OwogIHBhZGRpbmctdG9wOiAwOwogIGlucHV0IHsKICAgIHdpZHRoOiAxMDAlOwogICAgaGVpZ2h0OiAxMC41NTZ2dzsKICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7CiAgICBiYWNrZ3JvdW5kOiAjZmZmOwogICAgYm9yZGVyOiBub25lOwogICAgLyog5Zug5Li6IHZ3IOmDveaYr+e7j+i/h+aNoueulywg5aSq5bCP55qE5pWw5a2X5a655piT6KKr5b+955WlLAogICAg5pyJ5LiA5Lqb5rWP6KeI5Zmo5Lya5pi+56S65LiN5Ye65p2lCiAgICDkuIDoiKzlsI/kuo4gMTBweCDnmoTmg4XlhrXkuIss5oiR5Lus6YO95Lya55u05o6l5YaZ5YOP57SgICovCiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgIzY2NjsKICAgIG91dGxpbmU6IG5vbmU7CiAgfQogIC5lcnIgewogICAgYm9yZGVyLWNvbG9yOiByZWQ7CiAgfQogIC5zdWNjZXNzIHsKICAgIGJvcmRlci1jb2xvcjogIzY2NgogIH0KfQoK"},{"version":3,"sources":["AuthInput.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"AuthInput.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"input-wrapper\">\n    <!-- <h1>这里是输入框组件的 h1</h1> -->\n    <!-- 每当我们的这个 input 框接收到输入\n    都要进行一次判断, 看看合不合法\n    可以绑定 input 事件 -->\n\n      <!-- 这里 input 是一个输入框\n      我希望如果输入发生错误的时候它的样式被改变\n      方法是动态 v-bind 绑定一个 class 进来 -->\n\n      <!-- 为什么绑定 input 事件\n      不是绑定 change / blur 事件\n      是因为每次输入我们希望能够马上改变下划线样式, 不是等到失去焦点再判断 -->\n\n\n      <!-- 以前我们的写法是绑定一个变量, 直接以字符串变量作为 class\n      <input type=\"text\" :class=\"isValid\">\n      这样子只会绑定一个字符串 true / false\n      如果想根据布尔值动态添加 class 可以使用 对象的形式声明 -->\n      <!-- 这个对象里面是 key : value 键值对\n      其中 key 是准备添加的 class \n      value 是用来判断是否应该添加的布尔值 -->\n      <!-- 现在我们希望 isValid 为 false, 自动添加 err class -->\n      <!-- 假设我希望, 如果 isValid 为 true 则添加 success 的 class  -->\n      <!-- 现在input 已经可以根据 isValid 动态改变 class 接下来只需要 给 err\n      class 添加特定的 样式即可 -->\n      <input\n        :class=\"{\n          err: !isValid,\n          success: isValid\n        }\"\n        :type=\"type\" \n        :placeholder=\"placeholder\"\n        @input=\"checkValue\"\n        @blur=\"showAlert\"\n      >\n      <!-- 监控失去焦点事件\n      如果失去焦点(输入完毕)\n      这个 input 的数据还是不合法\n      需要弹窗提醒 -->\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      isValid: false\n    }\n  },\n  // 以前我们创建局部组件时候用到的\n  // 除了 template 以外的所有属性\n  // 全都放在 script export default 里面\n  // props 接收父组件传值\n  props: ['type', 'placeholder', 'rule', 'errMsg'],\n  methods: {\n    // 这是一个对象, 里面的每个属性都是一个函数\n    checkValue(event) {\n      // console.log('输入框的值发生了变化');\n      // 这里可以获取到输入框的值 event.target.value \n      // event 代表事件\n      // target 代表触发事件的dom\n      // value 代表这个输入框的值\n      // console.log(event.target.value);\n      // 假如我们现在想要验证这个输入框的数据\n      // 就是使用正则表达式,判断是否合法,然后返回一个true/false 即可\n      // const regExp = /.{3}/; 代表任意字符三个以上才合法\n      // const regExp = /.{3,10}/; 代表任意字符三个到十个以内都是合法 \n      \n      // 这里的正则是写死的, 其实这个输入框可能的使用场景非常多\n      // 比如用来输入用户名, 用来输入密码, 用来输入手机号\n      // 不同作用下, 这个输入框的验证正则应该是不一样\n      // 传参 像 type placeholder 一样\n      // const regExp = /^.{3,10}$/;\n      // 不可以再调用写死的正则, 需要根据父组件传进来的值生成正则表达式\n      const regExp = new RegExp(this.rule)   \n      // 这是正则的构造函数, 传入一个字符串即可   \n      // var a = /this.rule/ 这样不行, 因为他会以为 this.rule 是需要匹配的字符串, 不会作为变量\n      // 为什么要转换成正则对象, 不能直接用吗\n      // 只有转换成正则对象, 才会有 test 的方法\n      // 一个字符串是没有这种验证的方法的\n\n      // console.log(regExp);\n      // console.log(event.target.value);\n      this.isValid = regExp.test(event.target.value);\n      // console.log(isValid);\n      // 这个值 true / false 值放到 data 先存起来\n\n      // 这里checkValue之后应该主动将数据传递到父组件\n      // 第二个参数开始就是要传递的数据,可以被父组件的函数接受到\n      this.$emit('valueChange', event.target.value)\n      \n    },\n    showAlert() {\n      // 这里是失去焦点时候触发的函数\n      // 需要判断, 如果 this.isValid 已然为 false\n      // 证明不合法, 就要弹窗\n      // 如果合法, 什么都不做\n      if (!this.isValid) {\n        // 这里的处理可以根据自己的喜好, 提醒用户即可\n        // 正常这里的提醒方式, 是产品跟设计共同决定的\n        alert(this.errMsg)\n      }\n    }\n  }\n}\n</script>\n\n<style lang=\"less\" scoped>\n  // h1 {\n  //   color: green;\n  // }\n  .input-wrapper {\n    padding: 5.556vw;\n    padding-top: 0;\n    input {\n      width: 100%;\n      height: 10.556vw;\n      box-sizing: border-box;\n      background: #fff;\n      border: none;\n      /* 因为 vw 都是经过换算, 太小的数字容易被忽略,\n      有一些浏览器会显示不出来\n      一般小于 10px 的情况下,我们都会直接写像素 */\n      border-bottom: 1px solid #666;\n      outline: none;\n    }\n    .err {\n      border-color: red;\n    }\n    .success {\n      border-color: #666\n    }\n  }\n  \n</style>"]}]}